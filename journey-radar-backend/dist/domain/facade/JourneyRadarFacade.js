"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JourneyRadarFacade = void 0;
const IncidentReport_1 = require("../model/IncidentReport");
const JourneyService_1 = require("../service/JourneyService");
const JourneyProgressService_1 = require("../service/JourneyProgressService");
const sessions = new Map();
class InMemoryProgressRepository {
    journeyIdToProgresses = new Map();
    async save(progress) {
        const list = this.journeyIdToProgresses.get(progress.journeyId) ?? [];
        list.push(progress);
        this.journeyIdToProgresses.set(progress.journeyId, list);
    }
    async findByJourneyId(journeyId) {
        const list = this.journeyIdToProgresses.get(journeyId);
        if (!list || list.length === 0)
            return undefined;
        return list[list.length - 1];
    }
    async findAll() {
        const all = [];
        for (const list of this.journeyIdToProgresses.values()) {
            all.push(...list);
        }
        return all;
    }
}
class JourneyRadarFacade {
    incidentReportRepository;
    userContextService;
    userLocationRepository;
    journeyService;
    journeyProgressService;
    constructor(incidentReportRepository, userContextService, userLocationRepository, journeyProgressRepository, journeyService = new JourneyService_1.JourneyService()) {
        this.incidentReportRepository = incidentReportRepository;
        this.userContextService = userContextService;
        this.userLocationRepository = userLocationRepository;
        this.journeyService = journeyService;
        const repo = journeyProgressRepository ?? new InMemoryProgressRepository();
        this.journeyProgressService = new JourneyProgressService_1.JourneyProgressService(repo);
    }
    async planJourney(params) {
        console.log(`Domain: Planning journey from ${params.origin} to ${params.destination}...`);
        return { id: 'journey_123', status: 'PLANNED', from: params.origin, to: params.destination };
    }
    async getJourneyById(id) {
        console.log(`Domain: Getting journey by id ${id}...`);
        return { id, details: 'Journey details here' };
    }
    async checkHealth() {
        return { status: 'OK', domain: 'JourneyRadar' };
    }
    async reportIncident(userId, incidentType, description) {
        console.log(`Domain: User ${userId} reporting incident of type ${incidentType}`);
        // Get user context from the service
        const location = await this.userContextService.getCurrentLocation(userId);
        const reporter = await this.userContextService.getReporter(userId);
        const activeJourney = await this.userContextService.getActiveJourney(userId);
        console.log(`Domain: Inferred location (${location.latitude}, ${location.longitude}) for user ${userId}`);
        if (activeJourney) {
            console.log(`Domain: User is on journey from ${activeJourney.origin} to ${activeJourney.destination}`);
        }
        // Create incident report with inferred context
        const incidentReport = new IncidentReport_1.IncidentReport('', // ID will be generated by repository
        location, reporter, incidentType, // Type will be validated in the route
        { reportedOnRoute: activeJourney }, new Date(), description);
        // Save the incident report to the repository
        const savedIncident = await this.incidentReportRepository.save(incidentReport);
        console.log(`Domain: Incident ${savedIncident.id} reported successfully by ${savedIncident.reporter.type}`);
        return savedIncident;
    }
    async mockUserLocation(userId, longitude, latitude) {
        console.log(`Domain: Mocking location for user ${userId} at (${latitude}, ${longitude})`);
        await this.userLocationRepository.saveLocation({
            userId,
            longitude,
            latitude,
            timestamp: new Date()
        });
        return { userId, longitude, latitude };
    }
    // New contract-aligned methods
    async getJourney(origin, destination) {
        return this.journeyService.computeJourney(origin, destination);
    }
    async startJourney(journey) {
        const journeyId = `journey-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        sessions.set(journeyId, journey);
        const state = { route_index: 0, position_in_route: 0, updated_at: new Date().toISOString() };
        return { journey_id: journeyId, state };
    }
    async getJourneyProgress(journeyId, coordinates) {
        const journey = sessions.get(journeyId);
        if (!journey) {
            const empty = this.journeyService.computeJourney({ station: { name: 'Unknown' } }, { station: { name: 'Unknown' } });
            return await this.journeyProgressService.computeProgress(empty, coordinates, journeyId);
        }
        return await this.journeyProgressService.computeProgress(journey, coordinates, journeyId);
    }
}
exports.JourneyRadarFacade = JourneyRadarFacade;
