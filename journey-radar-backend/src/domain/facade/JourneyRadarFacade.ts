import { JourneyRadarCapabilities } from './JourneyRadarCapabilities';
import { IncidentReport } from '../model/IncidentReport';
import { IncidentReportRepository } from '../repository/IncidentReportRepository';
import { UserContextService } from '../service/UserContextService';
import { UserLocationRepository } from '../repository/UserLocationRepository';
import { Coordinates, Destination, Journey, JourneyProgress, JourneyStartResponse, Origin } from '../model/Journey';
import { JourneyService } from '../service/JourneyService';
import { JourneyProgressService } from '../service/JourneyProgressService';
import { JourneyProgressRepository } from '../repository/JourneyProgressRepository';
import { FinishedJourneyRepository } from '../repository/FinishedJourneyRepository';
import { FinishedJourney } from '../model/FinishedJourney';

const sessions: Map<string, Journey> = new Map();
const journeyIdToStartedAt: Map<string, string> = new Map();
const journeyIdToUserId: Map<string, string> = new Map();

class InMemoryProgressRepository implements JourneyProgressRepository {
  private readonly journeyIdToProgresses: Map<string, JourneyProgress[]> = new Map();

  async save(progress: JourneyProgress): Promise<void> {
    const list = this.journeyIdToProgresses.get(progress.journeyId) ?? [];
    list.push(progress);
    this.journeyIdToProgresses.set(progress.journeyId, list);
  }

  async findByJourneyId(journeyId: string): Promise<JourneyProgress | undefined> {
    const list = this.journeyIdToProgresses.get(journeyId);
    if (!list || list.length === 0) return undefined;
    return list[list.length - 1];
  }

  async findAll(): Promise<JourneyProgress[]> {
    const all: JourneyProgress[] = [];
    for (const list of this.journeyIdToProgresses.values()) {
      all.push(...list);
    }
    return all;
  }
}

export class JourneyRadarFacade implements JourneyRadarCapabilities {
  private readonly journeyProgressService: JourneyProgressService;

  constructor(
    private readonly incidentReportRepository: IncidentReportRepository,
    private readonly userContextService: UserContextService,
    private readonly userLocationRepository: UserLocationRepository,
    journeyProgressRepository?: JourneyProgressRepository,
    private readonly finishedJourneyRepository?: FinishedJourneyRepository,
    private readonly journeyService: JourneyService = new JourneyService()
  ) {
    const repo = journeyProgressRepository ?? new InMemoryProgressRepository();
    this.journeyProgressService = new JourneyProgressService(repo);
  }

  async planJourney(params: { origin: string; destination: string }): Promise<any> {
    console.log(`Domain: Planning journey from ${params.origin} to ${params.destination}...`);
    return { id: 'journey_123', status: 'PLANNED', from: params.origin, to: params.destination };
  }

  async getJourneyById(id: string): Promise<any> {
    console.log(`Domain: Getting journey by id ${id}...`);
    return { id, details: 'Journey details here' };
  }

  async checkHealth(): Promise<{ status: string; domain: string }> {
    return { status: 'OK', domain: 'JourneyRadar' };
  }

  async reportIncident(userId: string, incidentType: string, description?: string): Promise<IncidentReport> {
    console.log(`Domain: User ${userId} reporting incident of type ${incidentType}`);

    // Get user context from the service
    const location = await this.userContextService.getCurrentLocation(userId);
    const reporter = await this.userContextService.getReporter(userId);
    const activeJourney = await this.userContextService.getActiveJourney(userId);

    console.log(`Domain: Inferred location (${location.latitude}, ${location.longitude}) for user ${userId}`);
    if (activeJourney) {
      console.log(`Domain: User is on journey from ${activeJourney.origin} to ${activeJourney.destination}`);
    }

    // Create incident report with inferred context
    const incidentReport = new IncidentReport(
      '', // ID will be generated by repository
      location,
      reporter,
      incidentType as any, // Type will be validated in the route
      { reportedOnRoute: activeJourney },
      new Date(),
      description
    );

    // Save the incident report to the repository
    const savedIncident = await this.incidentReportRepository.save(incidentReport);

    console.log(`Domain: Incident ${savedIncident.id} reported successfully by ${savedIncident.reporter.type}`);
    return savedIncident;
  }

  async mockUserLocation(userId: string, longitude: number, latitude: number): Promise<{ userId: string; longitude: number; latitude: number }> {
    console.log(`Domain: Mocking location for user ${userId} at (${latitude}, ${longitude})`);

    await this.userLocationRepository.saveLocation({
      userId,
      longitude,
      latitude,
      timestamp: new Date()
    });

    return { userId, longitude, latitude };
  }

  // New contract-aligned methods
  async getJourney(origin: Origin, destination: Destination): Promise<Journey> {
    return this.journeyService.computeJourney(origin, destination);
  }

  async startJourney(journey: Journey): Promise<JourneyStartResponse> {
    const journeyId = `journey-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    sessions.set(journeyId, journey);
    const startedAt = new Date().toISOString();
    journeyIdToStartedAt.set(journeyId, startedAt);
    const state = { route_index: 0, position_in_route: 0, updated_at: startedAt };
    return { journey_id: journeyId, state };
  }

  async getJourneyProgress(journeyId: string, coordinates: Coordinates, userId?: string): Promise<JourneyProgress> {
    const journey = sessions.get(journeyId);
    if (!journey) {
      const empty = this.journeyService.computeJourney({ station: { name: 'Unknown' } }, { station: { name: 'Unknown' } });
      return await this.journeyProgressService.computeProgress(empty, coordinates, journeyId);
    }
    const progress = await this.journeyProgressService.computeProgress(journey, coordinates, journeyId);

    // Persist finished journey if reached destination and repository available
    try {
      const isAtFinalConnection = progress.progress.currentConnection.to.name === progress.lastStation.name;
      if (isAtFinalConnection && this.finishedJourneyRepository) {
        if (userId) {
          journeyIdToUserId.set(journeyId, userId);
        }
        const effectiveUserId = userId || journeyIdToUserId.get(journeyId);
        if (effectiveUserId) {
          const finished: FinishedJourney = {
            userId: effectiveUserId,
            journeyId,
            from: progress.firstStation,
            to: progress.lastStation,
            startedAt: journeyIdToStartedAt.get(journeyId) || new Date().toISOString(),
            finishedAt: new Date().toISOString(),
          };
          await this.finishedJourneyRepository.save(finished);
          // cleanup
          sessions.delete(journeyId);
          journeyIdToUserId.delete(journeyId);
          journeyIdToStartedAt.delete(journeyId);
        }
      }
    } catch (e) {
      // Non-fatal; history persistence should not break progress checks
      // eslint-disable-next-line no-console
      console.warn('History persistence failed:', e);
    }

    return progress;
  }

  async getFinishedJourneys(userId: string): Promise<FinishedJourney[]> {
    if (!this.finishedJourneyRepository) return [];
    return this.finishedJourneyRepository.findByUserId(userId);
  }
}
